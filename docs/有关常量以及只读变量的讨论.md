# 常量以及只读变量的讨论

本文档论述常量以及只读变量在 `DreamLang V2` 中的使用方式。

## 什么是只读变量

只读变量是只能赋值一次的变量，在初始化赋值后，变量的值和类型都无法改动，使用关键词 `val` 声明一个只读变量

```text
val zero: int = 0
```

### 只读变量的特性

- **单次赋值**：只读变量只能在声明时或者在第一次使用前被赋值
- **运行时存在**：只读变量在运行时仍然存在于内存中
- **类型安全**：一旦赋值，变量的类型和值都不可更改
- **可以使用表达式**：可以使用运行时才能确定的值进行赋值

```text
val result: int = computeValue() // 允许使用函数返回值
val user_input: string = getUserInput() // 允许使用运行时输入
```

### 只读变量的使用场景

1. **防止意外修改**：当需要保证变量在初始化后不被修改时
2. **函数参数**：用于表示函数参数不会被函数内部修改
3. **线程安全**：在多线程环境下减少数据竞争的风险
4. **清晰表达意图**：向其他开发者表明该变量不应被修改

## 什么是常量

常量是在编译期(进入运行时前)就被解析的值，对应的常量表达式会在编译时被展开计算。

现有两种方案实现常量(编译期表达式)的定义

1. 使用新关键词 `const`

```text
const pi: float = 3.14159
```

2. 使用编译期求值标记以及只读变量

```text
val pi: float = @CompileTime(3.14159)
```

如果采用编译期求值标记，似乎还有更加灵活的用法

```text
var varname: int = @CompileTime(2+8) // 对表达式 `2+8` 在编译期求值，但是将值赋予给一个可变变量 `varname`
```

### 常量的特性

- **编译期求值**：常量的值在编译时就已确定，不会在运行时改变
- **内联展开**：编译器可以直接在使用处内联展开常量的值，无需运行时查询
- **性能优势**：减少运行时的计算开销和内存访问
- **值限制**：常量值必须是在编译时就能确定的表达式

```text
const MAX_ARRAY_SIZE: int = 1024
const APP_VERSION: string = "v2.0.3"
const IS_DEBUG: bool = false
const BUFFER_SIZE: int = MAX_ARRAY_SIZE * 2 // 可以使用其他常量计算

val MAX_ARRAY_SIZE: int = @CompileTime(1024)
const APP_VERSION: string = @CompileTime("v2.0.3")
const IS_DEBUG: bool = @CompileTime(false)
const BUFFER_SIZE: int = @CompileTime(MAX_ARRAY_SIZE * 2)
```

## 常量与只读变量的区别

| 特性 | 常量 | 只读变量 |
|------|------|----------|
| 声明关键字 | `const` 或 `@CompileTime` | `val` |
| 赋值时机 | 编译期 | 编译期或运行时 |
| 内存占用 | 可能不占用运行时内存 | 占用运行时内存 |
| 表达式限制 | 只能使用编译期可确定的表达式 | 可以使用任何有效表达式 |
| 类型推断 | 支持 | 支持 |
| 全局作用域 | 适用于全局常量 | 适用于局部不可变数据 |
| 性能影响 | 可能提高性能 | 无特殊性能优势 |

## 最佳实践

### 何时使用常量

- 数学常数（π、e等）
- 配置参数（最大尺寸、缓冲区大小等）
- 编译标志（版本号、构建类型等）
- 需要在多处使用且不会变化的值
- 枚举值和魔数

### 何时使用只读变量

- 函数返回值需要保持不变时
- 用户输入或外部数据需要保护不被修改时
- 初始化后不应更改的对象引用
- 函数参数需要保护不被修改时

## 实现方案的选择

关于两种常量实现方案的比较：

1. 使用 `const` 关键字：
   - 优点：语法清晰，意图明确，与多种编程语言习惯一致
   - 优点：编译器可针对性优化
   - 缺点：增加新关键字

2. 使用 `@CompileTime()` 标记：
   - 优点：复用现有机制(目前已有类似语法`@Latex""`)，语法灵活
   - 优点：可以细粒度控制编译期求值
   - 缺点：语法较冗长，对初学者可能不够直观

