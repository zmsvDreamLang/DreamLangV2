# ref 类型的讨论

本文档描述了 `DreamLang V2` 中的两种变量类型（并非数据类型），以及对应语义。

## 使用 `var` 声明

通过 `var` 关键词声明的变量在赋值符两侧的表达式并不共享一个状态，而是互相独立。

```text
var a: int = 1
var b = a

a = a + 1  // 此时 a = 2, b = 1
```

赋值符右侧的表达式的值会被**深拷贝**后赋给左侧的变量，二者的值在赋值后互相独立。

## 使用 `ref` 声明

`ref` 关键词负责将等号右侧的表达式的引用赋值给等号的左侧的表达式，由于语言中的自动解引用机制，在后续计算中二者在形式上"共享一个状态"。

```text
var a: int = 1
ref b = a

a = a + 1  // 此时 a = 2, b = 2（自动解引用）
```

这里其实 b 的值不等于 2（严谨来说 b 的值是 "`a` 的引用"），但是在自动解引用机制的作用下，对于一切 b 的表达式求值中都会被自动解析为值而不是引用。如下例子更能说明自动解引用的作用。

```text
var a: int = 1
ref b = a

b = b + 1  // 此时 a = 2, b = 2（自动解引用）
```

对应 C 代码中需要显式解引用：

```c
int a = 1;
int* b = &a;

*b = *b + 1;  // 如果在 C 语言中直接写 b = b + 1 会导致后续程序运行不正常
```

### 自动解引用

在 DreamLang 中，自动解引用是一个重要的语言特性，它让引用类型的使用变得更加自然和直观。当引用类型变量出现在需要值的上下文中时，编译器会自动进行解引用操作，获取引用所指向的实际值。

自动解引用主要发生在以下几种情况：

1. **运算表达式中**：当引用变量参与数学运算、比较运算或逻辑运算时，会自动解引用获取其值。

```text
var a: int = 1
ref b = a

var c = b + 5  // b 自动解引用，c = 6
var d = b > 0  // b 自动解引用，d = true
```

2. **`var`赋值语句右侧**：当引用变量出现在赋值语句的右侧时，会自动解引用。

```text
var a: int = 10
ref b = a
var c = b  // b 自动解引用，c = 10
```

3. **函数参数传递**：当引用变量作为非引用类型参数传递给函数时，会自动解引用。

4. **返回值**：当函数返回引用类型，但返回类型声明为值类型时，会自动解引用。


自动解引用的机制使得 DreamLang 中使用引用变得更加简洁，避免了像 C/C++ 中显式解引用（如 `*ptr`）的语法负担，同时保留了引用的强大功能。这种设计使程序员可以专注于业务逻辑而不是底层内存操作。

需要注意的是，自动解引用仅发生在需要值的上下文中，在需要引用的上下文中（如将引用赋值给另一个引用变量时），不会触发自动解引用。

> 冷知识： `DreamLang` 中没有"引用的引用"

### 自动加引用

类似于自动解引用机制，在 `DreamLang` 中也存在自动加引用，例如：

```text
var a: int = 1
ref b = a  // 自动对 a 加引用，b 引用了 a
ref c = b  // 不涉及自动加引用或自动解引用，因为等号两侧都是引用类型
```

另一个例子：

```text
ref c: int = 1
```

这里看似简单，实则是一个背后原理稍显复杂的语法糖，这句语句的执行分为三步：

1. 创建一个匿名变量，将其值初始化为 1
2. 对这个匿名变量自动加引用
3. 将这个引用赋值给 c

## 引用的其他用法

在 `DreamLang` 中，引用允许被作为函数参数传递，传递后函数内部可以修改引用所指向的值，例如：

```text
fun add_to_the_first_parameter(ref fpm: int, spm: int) {
    fpm = fpm + spm  // 通过引用修改外部变量的值
}

var a: int = 2
var b: int = 3

add_to_the_first_parameter(a, b)  // 此时 a = 5, b = 3
```

这里函数没有返回值，但通过引用参数产生了副作用：修改了传入的第一个参数所指向的值。

让我们更进一步，尝试实现一个功能：

给定两个 int 类型变量，一个叫 x，一个叫 y，请将其中较大的那个变量赋值为一个 int 类型参数（或变量）c 的值，另一个保持不变，如果二者相同，则什么都不做

```text
// 函数定义：将较大的变量赋值为 c
fun set_larger_to_specific(ref a: int, ref b: int, c: int) {
    if a > b {
        a = c  // 如果 a 更大，将 a 赋值为 c
    } else if b > a {
        b = c  // 如果 b 更大，将 b 赋值为 c
    }
    // 如果 a 和 b 相等，什么也不做
}

var x: int = 10
var y: int = 20

// 调用函数
set_larger_to_specific(x, y, 114514)

// 此时 x = 10, y = 114514（因为 y 更大，被设置为了新值）
```

还有一种更加有意思的实现方式，通过返回引用：

```text
// 函数返回较大值的引用
fun get_larger_reference(ref a: int, ref b: int) -> (ref int) {
    if a > b {
        return a  // 返回 a 的引用
    } else {
        return b  // 返回 b 的引用
    }
}

var x: int = 5
var y: int = 10
var c: int = 20
ref larger = get_larger_reference(x, y)  // larger 引用了 y（因为 y 值更大）
larger = c  // 此时 x = 5, y = 20（通过引用修改了 y 的值）
```